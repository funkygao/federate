// Code generated by federate, DO NOT EDIT.
package {{.Package}};

import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

@Slf4j
public class FederatedIndirectRiskDetector {
    private final List<RiskDetector> detectors;
    private final ExecutorService executorService;

    public FederatedIndirectRiskDetector() {
        int processors = Runtime.getRuntime().availableProcessors();
        if (processors > 32) {
            processors = 8;
        }
        executorService = Executors.newFixedThreadPool(processors);

        detectors = new LinkedList<>();
        // builtin
        detectors.add(new RiskDetectorRequestMapping());
        detectors.add(new RiskDetectorConditional());

        // addon
        {{- range .AddOns }}
        detectors.add(new {{.}}());
        {{- end }}
    }

    public void detectRisks() throws Exception {
        String classpath = System.getProperty("java.class.path");
        String[] classpathEntries = classpath.split(File.pathSeparator);
        log.info("Starting risk detection ...");

        CountDownLatch latch = new CountDownLatch(classpathEntries.length);
        AtomicInteger activeJars = new AtomicInteger(0);

        for (String entry : classpathEntries) {
            if (entry.endsWith(".jar")) {
                executorService.submit(() -> {
                    try {
                        activeJars.incrementAndGet();
                        processJar(entry);
                    } catch (IOException e) {
                        log.error("Error processing jar: " + entry, e);
                    } finally {
                        activeJars.decrementAndGet();
                        latch.countDown();
                    }
                });
            } else {
                latch.countDown();
            }
        }

        latch.await();
        executorService.shutdown();

        System.out.println();
        for (RiskDetector detector : detectors) {
            System.out.printf("Potential conflict[%s] detected:\n", detector.conflictDesc());
            detector.reportRisks();
        }

        log.info("Risk detection completed.");
    }

    private void processJar(String jarPath) throws IOException {
        System.out.printf("Processing %s\n", jarPath);

        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            URL[] urls = { new URL("jar:file:" + jarPath + "!/") };
            try (URLClassLoader cl = URLClassLoader.newInstance(urls)) {
                while (entries.hasMoreElements()) {
                    JarEntry je = entries.nextElement();
                    if (je.isDirectory() || !je.getName().endsWith(".class") || je.getName().startsWith("META-INF/versions/")) {
                        continue;
                    }
                    String className = je.getName().substring(0, je.getName().length() - 6);
                    className = className.replace('/', '.');
                    try {
                        Class<?> clazz = cl.loadClass(className);
                        for (RiskDetector detector : detectors) {
                            try {
                                detector.visit(jarFile, clazz);
                            } catch (Throwable t) {
                                log.trace("Error analyzing class {} with detector {}: {}", className, detector.getClass().getSimpleName(), t.getMessage());
                            }
                        }
                    } catch (ClassNotFoundException | NoClassDefFoundError e) {
                        log.trace("{}: Skipping class {} due to: {}", jarPath, className, e.getMessage());
                    } catch (UnsupportedClassVersionError e) {
                        log.trace("{}: Skipping class {} due to unsupported version", jarPath, className);
                    } catch (Throwable t) {
                        log.trace("{}: Unexpected error processing class {}: {}", jarPath, className, t.getMessage());
                    }
                }
            }
        }
    }
}


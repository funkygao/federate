// Code generated by federate, DO NOT EDIT.
package {{.Package}};

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;
import org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionReaderUtils;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanNameGenerator;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.context.annotation.AnnotationBeanNameGenerator;
import org.springframework.context.annotation.ConfigurationClassPostProcessor;
import org.springframework.context.annotation.ScannedGenericBeanDefinition;
import org.springframework.util.StringUtils;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 自定义的 Bean 名称生成器，用于基于Java源代码注解的 Spring Bean 定义。
 *
 * 这个生成器扩展了 Spring 的 AnnotationBeanNameGenerator，适用于以下注解定义的 Bean：
 * 1. 构造型（stereotype）注解：
 *    - @Component
 *    - @Service
 *    - @Repository
 *    - @Controller
 *    - @RestController
 * 2. @Configuration 注解的配置类
 * 3. @Bean 注解定义的方法
 * 4. Mybatis Mapper/DAO 的注册通常由 MapperScannerConfigurer 或 @MapperScan 注解处理
 *    - @MapperScan(basePackages = "com.your.package.mappers", nameGenerator = FederatedAnnotationBeanNameGenerator.class)
 * 5. 其他使用 @Component 元注解的自定义注解
 *
 * 注意：
 * - 这个生成器不适用于 XML 配置中定义的 bean。
 * - 虽然它可以处理带有 @Aspect 注解的类，但前提是这些类同时使用了 @Component 或其他能够将其注册为 Spring bean 的注解。
 *
 * <p>Spring boot默认使用{@link AnnotationBeanNameGenerator}</p>
 * <p>{@link ConfigurationClassPostProcessor#setBeanNameGenerator(BeanNameGenerator)}</p>
 */
@Slf4j
public class FederatedAnnotationBeanNameGenerator extends AnnotationBeanNameGenerator {
    private static final Map<String, AtomicInteger> beanNameCount = new ConcurrentHashMap<>();
    private static final List<String> excludedBeanPatterns = new LinkedList<>();
    static {
        {{- range .ExcludedBeanPatterns }}
        excludedBeanPatterns.add("{{.}}");
        {{- end }}
    }

    /**
     * @param definition {@link ScannedGenericBeanDefinition}
     * @param registry   {@link DefaultListableBeanFactory}
     */
    @Override
    public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {
        if (!(definition instanceof AnnotatedBeanDefinition)) {
            throw new RuntimeException("Unexpected " + definition.getClass().getSimpleName());
        }

        final String fqcnBeanName = definition.getBeanClassName();
        if (shouldExcludeBean(fqcnBeanName)) {
            log.debug("Excluding bean: {}", fqcnBeanName);
            return null;
        }

        if (definition instanceof AnnotatedGenericBeanDefinition) {
            // 这个分支通常在以下情况下触发:
            // 1. 使用@Import注解导入的类
            // 2. @Configuration类中的@Bean方法定义的bean
            // 3. 通过AnnotationConfigApplicationContext的register()方法手动注册的类
            // 4. 使用BeanDefinitionBuilder或直接创建AnnotatedGenericBeanDefinition进行编程式Bean定义
            final String beanName = BeanDefinitionReaderUtils.generateBeanName(definition, registry);
            log.debug("AnnotatedGenericBeanDefinition: {}", beanName);
            return beanName;
        }

        // 检查 @Bean/@Service/@Component/Dao/... 注解中的 value 属性，并返回这个值作为 bean 名称
        String beanName = super.determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);
        if (StringUtils.hasText(beanName)) {
            log.trace("ignores {} explicit bean name: {}", fqcnBeanName, beanName);
            beanName = generateUniqueBeanName(beanName); // 生成唯一的 bean 名称
        }

        beanName = super.generateBeanName(definition, registry);
        if (registry.containsBeanDefinition(beanName)) {
            beanName = generateUniqueBeanName(fqcnBeanName); // 生成唯一的 bean 名称
        }

        log.trace("{} {}", fqcnBeanName, beanName);
        return beanName;
    }

    private String generateUniqueBeanName(String beanName) {
        AtomicInteger count = beanNameCount.computeIfAbsent(beanName, k -> new AtomicInteger(0));
        if (count.get() == 0) {
            count.incrementAndGet();
            return beanName;
        } else {
            String uniqueBeanName;
            synchronized (beanNameCount) {
                do {
                    uniqueBeanName = beanName + "#" + count.getAndIncrement();
                } while (beanNameCount.containsKey(uniqueBeanName));
                beanNameCount.put(uniqueBeanName, new AtomicInteger(1)); // 确保新生成的名称被记录
            }
            return uniqueBeanName;
        }
    }

    private boolean shouldExcludeBean(String className) {
        if (className == null) {
            return false;
        }
        for (String pattern : excludedBeanPatterns) {
            if (className.equals(pattern) || className.startsWith(pattern + ".")) {
                return true;
            }
        }
        return false;
    }
}

